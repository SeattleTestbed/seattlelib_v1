"""
<Program Name>
  xmlrpc_client.py

<Started>
  May 3, 2009

<Author>
  Michael Phan-Ba

<Purpose>
  Implements the client-side XML-RPC protocol.

"""


include urlparse.repy
include xmlrpc_common.repy


class xmlrpc_client_Client(object):
  """
  <Purpose>
    XML-RPC client implementation.

  <Side Effects>
    None.

  <Example Use>
    client = xmlrpc_client_Client("http://phpxmlrpc.sourceforge.net/server.php")
    print client.send_request("examples.getStateName", (1,))

  """


  USER_AGENT = "seattlelib/1.0.0"


  def __init__(self, url):
    """
    <Purpose>
      Create a new XML-RPC Client object to do RPC calls to the given
      server.

    <Arguments>
      url:
        A url containing the hostname, port, and path of the xmlrpc
        server. For example, "http://phpxmlrpc.soureforge.net/server.php".

    <Exceptions>
      None.

    """

    if not isinstance(url, (str, unicode)):
      raise ValueError("Invalid argument: url must be a URL string")

    urlcomponents = urlparse_urlsplit(url, "http", False)

    self.server_host = urlcomponents["hostname"]
    self.server_port = urlcomponents["port"] or 80
    self.server_path = urlcomponents["path"] or "/"
    if urlcomponents["query"]:
      self.server_path += "?" + urlcomponents["query"]

    if not self.server_host:
      raise ValueError("Invalid argument: url must have a valid host")


  def send_request(self, method_name, params, timeout=None):
    """
    <Purpose>
      Send a XML-RPC request to a XML-RPC server to do a RPC call.

    <Arguments>
      method_name:
        The method name.

      params:
        The method parameters.

    <Exceptions>
      socket.error on socket errors, including server timeouts.
      xmlrpc_common_Fault on a XML-RPC response fault.
      xmlrpc_common_XMLParseError on a XML-RPC structural parse error.
      xmlparse_XMLParseError on a general XML parse error.
      xmlrpc_common_ConnectionError on unexpected disconnects.
      xmlrpc_common_Timeout if the time limit is exceeded.

    <Side Effects>
      None.

    <Returns>
      The XML-RPC method return values.

    """

    starttime = getruntime()

    # Prepare the XML request.
    request_xml = xmlrpc_common_call2xml(method_name, params)

    try:
      # Assign None to socket so that socket will always be assigned
      # for the finally: block.
      socket = None

      # Open the connection to the server
      socket = openconn(self.server_host, self.server_port, timeout=timeout)

      # Timeout if the openconn took too long.
      if getruntime() - starttime > timeout:
        raise xmlrpc_common_Timeout()

      # Send the xmlrpc request.
      socket.send("POST %s HTTP/1.1\r\n" + \
          "User-Agent: %s\r\n" + \
          "Host: %s\r\n" + \
          "Content-Type: text/xml\r\n" + \
          "Content-Length: %d\r\n" + \
          "Connection: close\r\n\r\n%s" %
          (self.server_path, self.USER_AGENT, self.server_host,
            len(request_xml), request_xml))

      # Timeout if the request sending took too long.
      if getruntime() - starttime > timeout:
        raise xmlrpc_common_Timeout()

      # Receive the raw response.  If the server does not respond before
      # the timeout, a socket.error exception will be raised.
      response = ""
      while response.find("\r\n\r\n") < 0:
        try:
          recvdata = socket.recv(4096)
        except Exception, e:
          raise xmlrpc_common_ConnectionError("A connection error occurred.")

        if len(recvdata) == 0:
          raise xmlrpc_common_ConnectionError( \
              "Server closed connection before completing response.")

        response += recvdata

        # Timeout if recieving the response headers takes too long.
        if getruntime() - starttime > timeout:
          raise xmlrpc_common_Timeout()

      # Separate the header from the response body.
      raw_header, raw_content = response.split("\r\n\r\n", 1)
      raw_header_lines = raw_header.split("\r\n")

      # Parse headers for the appropriate server response.
      if raw_header_lines[0] != "HTTP/1.1 200 OK" and \
        raw_header_lines[0] != "HTTP/1.0 200 OK":
        raise ValueError("Invalid response protocol: %s" % raw_header_lines[0])

      # The response content size is initially 0.
      content_size = 0

      # Extract the response content size from the headers.
      for line in raw_header_lines[1:]:
        header_tag, header_value = line.split(":", 1)
        if header_tag.strip().lower() == "content-length":
          content_size = int(header_value.strip())

      # Get the rest of the response body.
      while len(raw_content) < content_size:
        raw_content += socket.recv(4096)

        # Timeout if recieving the body took too long.
        if getruntime() - starttime > timeout:
          raise xmlrpc_common_Timeout()

    finally:
      # Close the socket.  Connection: keep-alive is not yet supported.
      if socket is not None:  # socket will be None if openconn() threw an exception.
        socket.close()

    # Trim the response body and save it as the XML response.
    xml_response = raw_content[0:content_size]

    # Parse the XML response body into Python values.
    response_value = xmlrpc_common_response2python(xml_response)

    # If a fault was decoded, raise the exception.
    if isinstance(response_value, xmlrpc_common_Fault):
      raise response_value

    # Otherwise, return the results.
    return response_value
