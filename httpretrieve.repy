"""
<Program Name>
  httpretrieve.repy

<Started>
  August 19, 2009

<Author>
  Yafete Yemuru

<Purpose>
  Provides a method for retrieving content from web servers using the HTTP
  protocol. The content can be accessed as a file like object, or saved to
  a file or returned as a string.
"""




include urlparse.repy
include sockettimeout.repy
include http_hierarchy_error.repy
include urllib.repy





def httpretrieve_open(url, http_query=None, http_post=None, \
    http_header=None, header_timeout=30, content_timeout=30, \
    httpheader_limit=8192, httpcontent_limit=4194304):
  """
  <Purpose>
     Returns a file-like object that can be used to read the content from
     an HTTP server.

  <Arguments>
    url:
           The URL to perform a GET or POST request on.
    http_post (optional):
           A dictionary of form data to POST to the server. Passing
           a non-None value results in a POST request being sent to the
           server.
    http_query (optional):
           A dictionary of form data to send as a GET request's query
           string to the server.

           If http_post is omitted, the URL is retrieved with GET. If
           both http_post and http_query are omitted, there is no query
           string sent in the request.
    http_header (optional):
           A dictionary of supplemental HTTP request headers to add to the
           request.
    header_timeout (optional):
           A timeout for receiving the HTTP response headers from the
           server. Defaults to 30 seconds.
    content_timeout (optional):
           A timeout for receiving the body of the HTTP response from the
           server. Defaults to 30 seconds.
    httpheader_limit (optional):
           An optional limit on the quantity of HTTP response headers to
           accept from the server. Defaults to 8 kiB.
    httpcontent_limit (optional):
           An optional limit on the quantity of the HTTP response's body.
           Defaults to 4 MiB.

  <Exceptions>
    HttpUserInputError if given an invalid URL, or malformed limit /
      timeout values. This is also raised if the user attempts to call
      a method on the file-like object after closing it.

    HttpConnectionError if opening the connection or sending the HTTP
      request fails.

    HttpHeaderReceivingError if the timeout for recieving headers is
      exceeded or the limit on header data size is exceeded.

    HttpHeaderFormatError if the header data size is exceeded, the
      response is malformed, the Content-length response header is
      negative, or the Location response header is malformed.

    HttpContentReceivingError if the server fails to send the content,
      if the timeout for receiving is exceeded, or if the server
      connection fails for any reason while receiving content.

    HttpContentLengthError if the Content-length header returned by the
      server exceeds httpcontent_limit, or if the Content-length header
      doesn't match the amount of data sent by the server.

    HttpStatuscodeError if the status code isn't 2xx or 3xx.

  <Side Effects>
    None

  <Returns>
    Returns a file-like object which can be used to read the body of
    the response from the web server.
  """

  # Check if the URL is valid and get host, path, port and query
  (host, port, path, url_query) = _httpretrieve_parse_given_url(url)

  # Open connection to the web server
  try:
    sock = timeout_openconn(host, port)

  except Exception, e:
    raise HttpConnectionError('Error: opening a connection failed with given http server, Given: ' + str(url) + ' ' + str(e))

  # build an HTTP request using the given port, host, path and query
  httpheader = _httpretrieve_buildhttprequest(http_header, port, host, \
      path, url_query, http_query, http_post)

  # send HTTP request to the web server
  _httpretrieve_sendhttprequest(sock, httpheader)

  # receive the header lines from the web server
  httpheaderlines = _httpretrieve_receive_httpheader(sock, \
      header_timeout, httpheader_limit)

  # get the status code and status message from the HTTP response
  (http_status_number, http_status_msg) = \
      _httpretrieve_get_httpstatuscode(httpheaderlines)

  if http_status_number == '200':
    contentlength = _httpretrieve_get_contentlength(httpheaderlines)
    return _httpretrieve_filelikeobject(sock, contentlength, \
        httpcontent_limit, content_timeout)

  elif http_status_number == '301' or http_status_number == '302':
    # redirect to the new location via recursion
    sock.close()
    redirect_location = _httpretrieve_httpredirect(httpheaderlines)
    return httpretrieve_open(redirect_location)

  else:
    # Raise an exception detailing the status code and content of the
    # page to the user.
    contentlength = _httpretrieve_get_contentlength(httpheaderlines)
    http_errorcontent = \
        _httpretrieve_receive_httperror_content(sock, contentlength)
    _httpretrieve_raise_httpstatuscode_error(http_status_number, \
        http_status_msg, http_errorcontent)





def httpretrieve_save_file(url, filename, http_query=None, http_post=None, \
    http_header=None, header_timeout=30, content_timeout=30, \
    httpheader_limit=8192, httpcontent_limit=4194304):
  """
  <Purpose>
    Performs an HTTP request, and saves the content of the response to a
    file.

  <Arguments>
    filename:
           The file name to save the response to.
    Other arguments:
           See documentation for httpretrieve_open().

  <Exceptions>
    HttpRetrieveClientError if we cannot create the file.

    This function will all raise any exception raised by httpretrieve_open(),
    for the same reasons.

  <Side Effects>
    Writes the body of the response to 'filename'.

  <Returns>
    None
  """

  httpcontent = ''
  try:
    newfile = open(filename, 'w')
  except Exception, e:
    raise HttpRetrieveClientError( \
        'Error on creating a file to saving http content' + str(e))

  http_obj = httpretrieve_open(url, http_query, http_post, http_header, \
      header_timeout, content_timeout, httpheader_limit, httpcontent_limit)

  # Read from the file-like HTTP object into our file.
  while True:
    httpcontent = http_obj.read(1024)
    if httpcontent == '':
      # we're done reading
      newfile.close()
      http_obj.close()
      break
    newfile.write(httpcontent)



def httpretrieve_get_string(url, http_query=None, http_post=None, \
    http_header=None, header_timeout=30, content_timeout=30, \
    httpheader_limit=8192, httpcontent_limit=4194304):
  """
  <Purpose>
    Performs an HTTP request on the given URL, using POST or GET,
    returning the content of the response as a string. Uses
    httpretrieve_open.

  <Arguments>
    See httpretrieve_open.

  <Exceptions>
    See httpretrieve_open.

  <Side Effects>
    None.

  <Returns>
    Returns the body of the HTTP response (no headers).
  """

  http_obj = httpretrieve_open(url, http_query, http_post, http_header, \
      header_timeout, content_timeout, httpheader_limit, httpcontent_limit)
  httpcontent = http_obj.read()
  http_obj.close()
  return httpcontent



class _httpretrieve_filelikeobject:
  # This class implements a file-like object used for performing HTTP
  # requests and retrieving responses.

  def __init__(self, sock, contentlength, httpcontent_limit, content_timeout):
    self.sock = sock
    if contentlength == None:
      self.contentlengthisknown = False
    else:
      self.contentlengthisknown = True
      self.contentlength = contentlength
    self.httpcontent_limit = httpcontent_limit
    self.content_timeout = content_timeout
    self.fileobjclosed = False
    self.totalcontentisreceived = False
    self.totalread = 0



  def read(self, limit = None):
    """
    <Purpose>
      Behaves like Python's file.read(), with the potential to raise
      additional informative exceptions.

    <Arguments>
      limit (optional):
            The maximum amount of data to read. If omitted or None, this
            reads all available data.

    <Exceptions>
      See file.read()'s documentation, as well as that of
      httpretrieve_open().

    <Side Effects>
      None.

    <Returns>
      See file.read().
    """

    if self.fileobjclosed == True:
      raise HttpUserInputError('Http Error: filelikeobj is closed')

    if self.totalcontentisreceived:
      return ''

    if limit == None:
      readhaslimit = False
      left_to_read = 1024
    else:
      if not type(webpage_content) == int:
        raise HttpUserInputError( \
            'User input Error: given a none int to receive' + str(e))
      elif limit < 0:
        raise HttpUserInputError( \
            'User input Error: given a negative number to receive, given: ' + \
            str(limit))
      readhaslimit = True
      left_to_read = limit

    self.sock.settimeout(self.content_timeout)

    # Try to read up to limit, or until there is nothing left.
    httpcontent = ''
    while True:
      try:
        content = self.sock.recv(left_to_read)

      except SocketTimeoutError:
        self.sock.close()
        raise HttpContentReceivingError( \
            'Timeout Error on receiving content: server taking too long to send content')

      except Exception, e:
        if 'Socket closed' not in str(e):
          self.sock.close()
          raise HttpContentReceivingError('Error on receiving content:' + str(e))

        self.totalcontentisreceived = True
        break

      else:
        if len(content) >= self.httpcontent_limit:
          raise HttpContentLengthError('content length exceeded ' + \
              self.httpcontent_limit)

        httpcontent += content
        if readhaslimit:
          self.totalread += len(content)
          if len(content) == left_to_read:
            break
          else:
            left_to_read -= len(content)

    # Check if there was an error receiving the HTTP response.
    self._check_recieving_error(readhaslimit, httpcontent)

    return httpcontent



  def close(self):
    """
    <Purpose>
      Close the file-like object.

    <Arguments>
      None

    <Exceptions>
      None

    <Side Effects>
      Disconnects from the HTTP server.

    <Returns>
      Nothing
    """
    self.fileobjclosed = True
    self.sock.close()



  def _check_recieving_error(self, readhaslimit, httpcontent):
    if len(httpcontent) == 0:
      self.sock.close()
      raise HttpContentLengthError('Error on recieving content: ' + \
          'received a http header but didnt receive any http content')

    if self.contentlengthisknown:
      if readhaslimit and self.totalcontentisreceived:
        if self.totalread != self.contentlength:
          self.sock.close()
          raise HttpContentLengthError('Total length read with limit ' + \
              'did not match the content length: total read: ' + \
              str(self.totalread) + ' content length: ' + \
              str(self.contentlength))

      if readhaslimit == False:
        if len(httpcontent) != self.contentlength:
          self.sock.close()
          raise HttpContentLengthError('Total received length did not ' + \
              'match the content length: received: ' + \
              str(len(httpcontent)) + ' content length : ' + \
              str(self.contentlength))




def _httpretrieve_parse_given_url(url):
  # Checks that the URL is in the right format and returns a tuple of host,
  # port, path and query.
  try:
    urlparse = urlparse_urlsplit(url)
  except Exception, e:
    raise HttpUserInputError('Given URL error: ' + str(e))
  else:
    if urlparse['scheme'] != 'http':
      raise HttpUserInputError('Given URL error: the given protocol ' + \
          urlparse['scheme'] + ' isnt supported')
    if urlparse['hostname'] == None:
      raise HttpUserInputError('Given URL error: host name is not given')

    host = urlparse['hostname']
    path = urlparse['path']
    query = urlparse['query']
    port = urlparse.get('port', 80)

    return (host, port, path, query)




def _httpretrieve_buildhttprequest(http_header, port, host, path, url_query,
    dict_query, http_post):
  # Sends the HTTP request.

  if http_post != None:
    # There is a posted data, use HTTP POST.

    if not type(http_post) == dict:
      raise HttpUserInputError('The given http_post is not a ' + \
          'dictionary, given: ' + str(type(http_post)))

    # Convert the dictionary of form values into a POST message body.
    try:
      http_post = urllib_quote_parameters(http_post)
    except Exception, e:
      raise HttpUserInputError('Error encoding the given http post ' + \
          'dictionary ' + str(http_post) + str(e))

    # Build the minimal HTTP request header -- includes only the request
    # and the Host field.
    httpheader = _httpretrieve_httprequestmain_header('POST', url_query, \
        dict_query, path, host, port)

    # Build the rest of the request.
    httpheader += _httpretrieve_parse_clienthttpheader(http_header)
    httpheader += 'Content-Length: ' + str(len(http_post)) + '\r\n'
    httpheader += '\r\n'
    httpheader += http_post

  else:
    # There is no posted data, use HTTP GET.
    httpheader = _httpretrieve_httprequestmain_header('GET', url_query, \
        dict_query, path, host, port)
    httpheader += _httpretrieve_parse_clienthttpheader(http_header)
    httpheader += '\r\n'

  # return header with a new line which is signal for http header is done
  return httpheader




def _httpretrieve_httprequestmain_header(http_command, url_query, \
    dict_query, path, host, port):
  # Builds a minimal HTTP request, returning it as a string.

  # Sanity check -- the user should have only given us one set of data.
  if url_query != '' and dict_query != None:
    raise HttpUserInputError('Cant input a http query with the url and ' + \
        'an extra parameter dictionary with a http query')

  elif dict_query != None:
    # Send form data via GET.
    try:
      encoded_query = '?' + urllib_quote_parameters(dict_query)
    except Exception, e:
      raise HttpUserInputError('Error encoding the given http ' + \
          'query dictionary ' + str(dict_query) + str(e))

  elif url_query != '':
    # Send an arbitrary string via GET.
    encoded_query = '?' + url_query
  else:
    encoded_query = ''

  # A non-empty path is a required part of an HTTP request.
  addpath = '/'
  if path != '':
    addpath = path

  main_httpheader = http_command + ' ' + addpath + encoded_query + \
      ' HTTP/1.0\r\n'

  # We don't need to include the port in the Host header if it is 80.
  addport = ''
  if port != 80:
    addport = ':' + str(port)

  main_httpheader += 'Host: ' + host + addport + '\r\n'
  return main_httpheader




def _httpretrieve_parse_clienthttpheader(http_header):
  # Converts a dictionary of HTTP request headers into a string.

  if http_header == None:
    return ''

  elif not type(http_header) == dict:
    raise HttpUserInputError('The given http_post is not a dictionary, ' + \
        'given: ' + str(type(http_header)))

  else:
    clienthttpheader = ''
    for key, val in http_header.items():
      clienthttpheader += key + ' : ' + val + '\r\n'
    return clienthttpheader




def _httpretrieve_sendhttprequest(sock, httpheader):
  # Send the HTTP request; raise an exception on error.
  try:
    sock.send(httpheader)
  except Exception, e:
    sock.close()
    raise HttpConnectionError('Connection error: on sending http ' + \
        'request to server ' + str(e))




def _httpretrieve_receive_httpheader(sock, header_timeout, httpheader_limit):
  # Receives the HTTP headers only. Returns them as a list of strings.

  sock.settimeout(header_timeout)

  httpheader_received = 0
  httpheader = ''
  while True:
    # CRLFCRLF separates the HTTP headers from the body of the response.
    if '\r\n\r\n' in httpheader:
      return httpheader.split('\r\n')

    # Against the HTTP spec, we also accept LFLF as a mark of reaching the
    # end of the headers.
    if '\n\n' in httpheader:
      return httpheader.split('\n')

    if httpheader_limit == httpheader_received:
      sock.close()
      raise HttpHeaderFormatError('Http header length Error: The http ' + \
          'header is too long, exceeded 8 kb')

    try:
      content = sock.recv(1)
      httpheader_received += 1

    except SocketTimeoutError:
      raise HttpHeaderReceivingError('Timeout Error on receiving ' + \
          'header: server taking too long to send http header')

    except Exception, e:
      sock.close()
      raise HttpHeaderReceivingError('Error on recieving http ' + \
          'header: ' + str(e))

    else:
      httpheader += content




def _httpretrieve_get_httpstatuscode(httpHeaderLines):
  # Checks if the status code does not indicate an error.

  # The first line of an HTTP response is composed of:
  # HTTP<version> http_status_number http_status_msg
  httpstatusheader = httpHeaderLines[0]
  headersplit = httpstatusheader.split(' ', 2)

  if len(headersplit) != 3:
    raise HttpHeaderFormatError('Invalid Http header status code ' + \
        'format: Correct format is HTTP<version> http_status_number ' + \
        'http_status_msg: Given '  + httpstatusheader)
  if not httpstatusheader.startswith('HTTP'):
    raise HttpHeaderFormatError('Invalid Http header status code ' + \
        'format: Http header status code should start of with ' + \
        'HTTP<version> but given: '  + httpstatusheader)

  http_version = headersplit[0]

  try:
    int(headersplit[1])
  except ValueError, e:
    raise HttpHeaderFormatError('Invalid Http header status code ' + \
        'format: Status number should be a int, Given: ' + \
        str(headersplit[1]) + str(e))
  else:
    http_status_number = headersplit[1]

  http_status_msg = headersplit[2]
  return http_status_number, http_status_msg




def _httpretrieve_receive_httperror_content(sock, contentlength):
  # Receive the error message (this is called when the server returns an
  # 'error' response).

  httperror_content = ''
  while True:
    try:
      content = sock.recv(1024)

    except SocketTimeoutError:
      raise HttpContentReceivingError('Timeout Error on receiving http ' + \
          'error content: server taking too long to send http error content')
    except Exception, e:
      if 'Socket closed' not in str(e):
        sock.close()
        raise HttpContentReceivingError('Error on receiving http error ' + \
            'content: ' + str(e))
      break

    else:
      httperror_content += content

  if contentlength != None:
    if contentlength != len(httperror_content):
      raise HttpContentLengthError('Error on receiving http error ' + \
          'content: received conent length: ' + \
          str(len(httperror_content)) + ' actual content length: ' + \
          str(contentlength))
  return httperror_content




def _httpretrieve_raise_httpstatuscode_error(http_status_number, http_status_msg, http_errorcontent):
  # Raises an exception for the status code.

  # Arbitrarily chosen individual status codes:
  if http_status_number == '202':
    raise HttpError202('Http response error: ' + http_status_number + ' ' + http_status_msg +  ' http proccesing not responding. Http error content: ' + http_errorcontent)
  elif http_status_number == '204':
    raise HttpError204('Http response error: ' + http_status_number + ' ' + http_status_msg +  ' thier is no http body content. Http error content: ' + http_errorcontent)
  elif http_status_number == '300':
    raise HttpError300('Http response error: ' + http_status_number + ' ' + http_status_msg +  ' multiple redirect isnt suported. Http error content: ' + http_errorcontent)
  elif http_status_number == '404':
    raise HttpError404('Http response error: ' + http_status_number + ' ' + http_status_msg +  ' cant find anything matching the given url. Http error content: ' + http_errorcontent)
  elif http_status_number == '403':
    raise HttpError403('Http response error: ' + http_status_number + ' ' + http_status_msg +  ' the request was illegal. Http error content: ' + http_errorcontent)
  elif http_status_number == '400':
    raise HttpError400('Http response error: ' + http_status_number + ' ' + http_status_msg +  ' the request contians bad syntex. Http error content: ' + http_errorcontent)
  elif http_status_number == '500':
    raise HttpError500('Http response error: ' + http_status_number + ' ' + http_status_msg +  ' The server encountered an unexpected condition. Http error content: ' + http_errorcontent)
  elif http_status_number == '502':
    raise HttpError502('Http response error: ' + http_status_number + ' ' + http_status_msg +  ' acting like a gateway received an invalid response. Http error content: ' + http_errorcontent)

  # Ranges:
  elif http_status_number >= '100' and http_status_number < '200':
    raise HttpError1xx('Http response error: Information ' + http_status_number + ' ' + http_status_msg + '.Http error content: ' + http_errorcontent)
  elif http_status_number > '200' and http_status_number < '300':
    raise HttpError2xx('Http response error: success error ' + http_status_number + ' ' + http_status_msg + '.Http error content: ' + http_errorcontent)
  elif http_status_number >= '300' and http_status_number < '400':
    raise HttpError3xx('Http response error: Redirection error' + http_status_number + ' ' + http_status_msg + '.Http error content: ' + http_errorcontent)
  elif http_status_number >= '400' and http_status_number < '500':
    raise HttpError4xx('Http response error: client error ' + http_status_number + ' ' + http_status_msg + '.Http error content: ' + http_errorcontent)
  elif http_status_number >= '500' and http_status_number < '600':
    raise HttpError5xx('Http response error: server error: ' + http_status_number + ' ' + http_status_msg + '.Http error content: ' + http_errorcontent)
  else:
    raise HttpStatusCodeError('Http response error: invalid http status response, given ' + http_status_number + '.Http error content: ' + http_errorcontent)




def _httpretrieve_httpredirect(httpheaderlines):
  # Determine redirect location from response headers.

  for headerline in httpheaderlines:
    if headerline.startswith('Location: '):
      redirect = headerline[len('Location: '):]

      if len(redirect) == 0:
        raise HttpHeaderFormatError('Http header redirection format ' + \
            'error: http server gave a redierect location with no URL')
      return redirect

  raise HttpHeaderFormatError('Http header redirection format error: ' + \
      'http redirect header didnt include the location')




def _httpretrieve_get_contentlength(httpheaderlines):
  # Determines the value of the Content-Length header.

  for headerline in httpheaderlines:
    if headerline.startswith('Content-Length: '):
      try:
        contentlength = int(headerline[len('Content-Length: '):])
      except ValueError, e:
        raise HttpHeaderFormatError('Http header Content-Length format ' + \
            'error: http server provided content length that isnt a int ' + \
            str(e))

      if contentlength <= 0:
        raise HttpHeaderFormatError('Http header Content-Length format ' + \
            'error: provided content length with invalid number ' + \
            str(contentlength))
      else:
        return contentlength

  return None
