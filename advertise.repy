"""
Author: Justin Cappos

Start Date: October 14, 2008

Description:
A stub that allows different announcement types.   I'd make this smarter, but
the user won't configure it, right?


Raises an AdvertiseError exception if there is a problem advertising with either service

"""

include listops.repy
include openDHTadvertise.repy
include centralizedadvertise.repy

include parallelize.repy

nodemanager_announce_context = {}
nodemanager_announce_context["skipDHT"] = 0
nodemanager_announce_context["previousDHTskip"] = 1
nodemanager_announce_context["skipcentral"] = 0
nodemanager_announce_context["previouscentralskip"] = 1
nodemanager_announce_context_lock = getlock()


# an exception to indicate an error occured while advertising
class AdvertiseError(Exception):
  pass




def _try_advertise_announce(args):
  # Helper function used by advertise_announce(). This is the worker process
  # run in parallel for DHT and central announces.
  which_service, key, value, ttlval, exceptions = args

  if which_service not in ("central", "DHT"):
    raise AdvertiseError("Incorrect service type used in internal function _try_advertise_announce.")

  try:
    if which_service == "central":
      centralizedadvertise_announce(key, value, ttlval)
    else:
      openDHTadvertise_announce(key, value, ttlval)

    nodemanager_announce_context_lock.acquire()
    try:
      nodemanager_announce_context["previous" + which_service + "skip"] = 1
    finally:
      nodemanager_announce_context_lock.release()

  except Exception, e:
    nodemanager_announce_context_lock.acquire()
    try:
      exceptions[0] += 'announce error (type: ' + which_service + '): ' + str(e)
      nodemanager_announce_context["skip" + which_service] = \
          nodemanager_announce_context["previous" + which_service + "skip"] + 1
      nodemanager_announce_context["previous" + which_service + "skip"] = \
          min(nodemanager_announce_context["previous" + which_service + "skip"] * 2, 16)
    finally:
      nodemanager_announce_context_lock.release()





def advertise_announce(key, value, ttlval, concurrentevents=2, timeout=60):
  """
  <Purpose>
    Announce (PUT) a value at the given key in the central advertise service,
    openDHT, or both.

  <Arguments>
    key:
            The key to store the value at.

    value:
            The value to store.

    ttlval:
            Time in seconds to persist the associated key<->value pair.
    
    concurrentevents (optional, defaults to 2):
            How many services to announce on in parallel.

    timeout (optional, defaults to 60):
            After this many seconds (can be a float or int type), give up.

  <Exceptions>
    AdvertiseError if something goes wrong.

  <Side Effects>
    Spawns as many worker events as concurrentevents specifies, limited by the
    number of services available (currently 2).

  <Returns>
    None.
  """

  # Wrapped in an array so we can modify the reference (python strings are immutable).
  exceptions = [''] # track exceptions that occur and raise them at the end

  parallize_worksets = []
  start_time = getruntime()

  for service_type in ("central", "DHT"):
    if nodemanager_announce_context["skip" + service_type] == 0:
      parallize_worksets.append((service_type, key, value, ttlval, exceptions))

    else:
      nodemanager_announce_context_lock.acquire()
      try:
        nodemanager_announce_context["skip" + service_type] = \
            nodemanager_announce_context["skip" + service_type] - 1
      finally:
        nodemanager_announce_context_lock.release()

  ph = parallelize_initfunction(parallize_worksets, _try_advertise_announce, \
      concurrentevents=concurrentevents)

  while not parallelize_isfunctionfinished(ph):
    sleep(0.2)
    if getruntime() - start_time > timeout:
      parallelize_abortfunction(ph)
      break

  # Note: closefunction() doesn't actually abort future functions like
  # it says it will.
  parallelize_closefunction(ph)

  if exceptions[0] != '':
    raise AdvertiseError, exceptions

  return None




def _try_advertise_lookup(args):
  # Helper function used by advertise_lookup(). This is the worker process
  # run in parallel for DHT and central lookups.
  which_service, key, maxvals = args

  if which_service not in ("central", "DHT"):
    raise AdvertiseError("Incorrect service type used in internal function _try_advertise_lookup.")

  try:
    if which_service == "central":
      return centralizedadvertise_lookup(key, maxvals)
    else:
      return openDHTadvertise_lookup(key, maxvals)
  
  except Exception, e:
    return []




def advertise_lookup(key, maxvals=100, lookuptype=['central','opendht'], \
    concurrentevents=2, timeout=60):
  """
  <Purpose>
    Lookup (GET) (a) value(s) stored at the given key in the central advertise
    server, openDHT, or both.

  <Arguments>
    key:
            The key used to lookup values.

    maxvals (optional, defaults to 100):
            Maximum number of values to return.

    lookuptype (optional, defaults to ['central', 'opendht']):
            Which services to employ looking up values.
    
    concurrentevents (optional, defaults to 2):
            How many services to lookup on in parallel.

    timeout (optional, defaults to 60):
            After this many seconds (can be a float or int type), give up.

  <Exceptions>
    AdvertiseError if something goes wrong.

  <Side Effects>
    Spawns as many worker events as concurrentevents specifies, limited by the
    number of services in lookuptype.

  <Returns>
    All unique values stored at the key.
  """

  parallel_worksets = []
  start_time = getruntime()

  for type in lookuptype:
    if type == "central":
      parallel_worksets.append(("central", key, maxvals))
    elif type == "opendht":
      parallel_worksets.append(("DHT", key, maxvals))
    else:
      raise AdvertiseError("Incorrect service type '" + type + "' passed to advertise_lookup().")

  ph = parallelize_initfunction(parallel_worksets, _try_advertise_lookup, \
      concurrentevents=concurrentevents)

  while not parallelize_isfunctionfinished(ph):
    sleep(0.2)
    if getruntime() - start_time > timeout:
      parallelize_abortfunction(ph)
      break

  parallel_results = parallelize_getresults(ph)['returned']
  results = []

  for parallel_result in parallel_results:
    _, return_value = parallel_result
    results += return_value

  parallelize_closefunction(ph)

  return listops_uniq(results)
