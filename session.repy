# This module wraps communications in a signaling protocol.   The purpose is to
# overlay a connection-based protocol with explicit message signaling.   
#
# The protocol is to send the size of the message followed by \n and then the
# message itself.   The size of a message must be able to be stored in 
# sessionmaxdigits.   A size of -1 indicates that this side of the connection
# should be considered closed.
#
# Note that the client will block while sending a message, and the receiver 
# will block while recieving a message.   
#
# While it should be possible to reuse the connectionbased socket for other 
# tasks so long as it does not overlap with the time periods when messages are 
# being sent, this is inadvisable.

class SessionEOF(Exception):
  pass

sessionmaxdigits = 20

# get the next message off of the socket...
def session_recvmessage(socketobj):

  # This is our length header.
  messagesizestring = ''
  
  # This is our read overflow buffer.
  readoverflow = ''

  # Flag
  runloop = True

  # first, read the number of characters...
  for junkcount in range(sessionmaxdigits):
    # There is a less naive way of doing this. If we assume that the sender is
    # also using session.repy, we are guaranteed packets of minimum size 3.
    # This is because the packet must contain a length header of at least one 
    # byte, a '\n' delimiter, and at least one byte of packet data. We can 
    # account for edge cases where we read too much data with ease as well.
    # currentbyte = socketobj.recv(1)  # Updated 12/12/11
    currentbytes = socketobj.recv(3)

    if '\n'in currentbytes:
      # We cannot use split for this. If a user has placed a \n character in 
      # their packet for whatever reason, using split will lead to strange 
      # errors. We have to parse by hand.

      runloop = False
      delimiter_found = False
      
      if currentbytes[0] == '\n':
        readoverflow += currentbytes[1:]
        delimiter_found = True
      else:
        messagesizestring += currentbytes[0]
      if currentbytes[1] == '\n':
        readoverflow += currentbytes[2]
      else:
        # Guard against an edge case.
        if not delimiter_found:
          messagesizestring += currentbytes[1]

    else:
      messagesizestring += currentbytes
      

    if not runloop:
      break

    # 12/12/11 - Since we aren't reading these values in bytewise anymore, 
    #            this check no longer makes sense.
    # not a valid digit
    # if currentbyte not in '0123456789' and messagesizestring != '' and currentbyte != '-':
    #   raise ValueError, "Bad message size"

  if runloop:
    # Then we hit sessionmaxdigits.
    raise Exception("Could not discern length of packet header!")

  try:
    messagesize = int(messagesizestring)
  except ValueError:
    raise ValueError, "Bad message size"
  
  # nothing to read...
  if messagesize == 0:
    return ''

  # end of messages
  if messagesize == -1:
    raise SessionEOF, "Connection Closed"

  if messagesize < 0:
    raise ValueError, "Bad message size"

  data = readoverflow
  while len(data) < messagesize:
    chunk =  socketobj.recv(messagesize-len(data))
    if chunk == '': 
      raise SessionEOF, "Connection Closed"
    data = data + chunk

  return data

# a private helper function
def session_sendhelper(socketobj,data):
  sentlength = 0
  # if I'm still missing some, continue to send (I could have used sendall
  # instead but this isn't supported in repy currently)
  while sentlength < len(data):
    thissent = socketobj.send(data[sentlength:])
    sentlength = sentlength + thissent



# send the message 
def session_sendmessage(socketobj,data):
  header = str(len(data)) + '\n'
  # Sending these piecemeal does not accomplish anything, and can contribute 
  # to timeout issues when run by constantly overloaded machines.
  # session_sendhelper(socketobj,header)

  # Concatenate the header and data, rather than sending both separately.
  complete_packet = header + data

  # session_sendhelper(socketobj,data)

  session_sendhelper(socketobj, complete_packet)

