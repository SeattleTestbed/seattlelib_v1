include xmlparse.repy
include urllib.repy

def _xmlrpc_server_lookup_ip(hostname):
  # Looks up an ip address for a given hostmask.  Throws an exception for
  # invalid hostnames.

  # The third item of the 3-tuple returned by gethostbyname_ex() is a list
  # of ips for this hostname.
  listen_ips = gethostbyname_ex(hostname)[2]

  # If the host to listen on resolves to more than one ip, we can't behave
  # in a deterministic manner.  So, we except.
  if len(listen_ips) != 1:
    raise ArgumentError()

  return listen_ips[0]




class xmlrpc_server_Binary:
  # Note: this should become part of the shared XMLRPC codebase.
  """
  <Purpose>
    Wrapper class for base64-encoded binary data in XMLRPC requests and
    responses.

  <Side Effects>
    None.

  <Example Use>
    # create a new binary "blob" to return to the caller
    def foo():
      return xmlrpc_server_Binary("\\xfbZt\\xe2")
    # This should mostly only be used for sending and recieving
    # base64-encoded binary data over XMLRPC.
  """

  def __init__(self, data=None):
    if data is None:
      self.data = ""
    else:
      self.data = base64_b64decode(data)




def _xmlrpc_server_valuenode_to_python(valuenode):
  # Converts an xmlparse_XMLTreeNode of a 'value' tag to a real
  # python value, and returns this value.

  # Note: this function will be replaced by or moved into Michael's
  # xmlrpc_Marshaller library at some point.

  if valuenode.children is None:
    # The XMLRPC spec says that values without explicit type are assumed
    # to be strings.
    return urllib_unquote(valuenode.content)

  if len(valuenode.children) != 1:
    raise xmlrpc_server_ClientError()

  typenode = valuenode.children[0]

  if typenode.tag_name == "string":
    if typenode.content is None:
      raise xmlrpc_server_ClientError()

    return urllib_unquote(typenode.content)

  elif typenode.tag_name == "boolean":
    if typenode.content is None:
      raise xmlrpc_server_ClientError()

    return bool(int(typenode.content))

  elif typenode.tag_name == "int" or typenode.tag_name == "i4":
    if typenode.content is None:
      raise xmlrpc_server_ClientError()

    return int(typenode.content)

  elif typenode.tag_name == "array":
    if typenode.children is None or len(typenode.children) != 1:
      raise xmlrpc_server_ClientError()

    datanode = typenode.children[0]

    # Arrays have a single child element named "data", which contains a
    # series of <value> elements.
    if datanode.tag_name != "data" or datanode.children is None:
      raise xmlrpc_server_ClientError()

    result_array = []
    for subvalue in datanode.children:
      result_array.append(_xmlrpc_server_valuenode_to_python(subvalue))

    return result_array

  elif typenode.tag_name == "double":
    if typenode.content is None:
      raise xmlrpc_server_ClientError()

    return float(typenode.content)
  
  elif typenode.tag_name == "dateTime.iso8601":
    # We don't really have a concept of datetime in RePy
    raise xmlrpc_server_ClientError()
  
  elif typenode.tag_name == "base64":
    if typenode.content is None:
      raise xmlrpc_server_ClientError()

    # Python doesn't really have a concept of a distinction between binary
    # strings and ordinary strings, so we have a wrapper class for base64-
    # encoded XMLRPC data. This is identical to the way the Python version
    # handles <base64> values.
    return xmlrpc_server_Binary(typenode.content)

  elif typenode.tag_name == "struct":
    if typenode.children is None:
      raise xmlrpc_server_ClientError()

    # Python interprets XMLRPC "struct" objects as plain dictionaries.
    resultdict = {}

    for membernode in typenode.children:
      # Each member in an XMLRPC struct has exactly two children elements:
      # <name> and a <value>.
      if membernode.children is None or len(membernode.children) != 2:
        raise xmlrpc_server_ClientError()

      memberdict = {}

      # Here we loop through each child element of this <member> node, and
      # we take <name> or <value> nodes and save them into memberdict as we
      # run across them.
      for childnode in membernode.children:
        if childnode.tag_name == "name":
          if childnode.content is None:
            raise xmlrpc_server_ClientError()

          memberdict["name"] = childnode.content
        elif childnode.tag_name == "value":
          memberdict["value"] = _xmlrpc_server_valuenode_to_python(childnode)

      if not memberdict.has_key("name") or not memberdict.has_key("value"):
        raise xmlrpc_server_ClientError()

      resultdict[memberdict["name"]] = memberdict["value"]

    return resultdict





def _xmlrpc_server_python_to_xmlvalue(pythonval):
  # Converts a python value to an xml 'value' tag string, and returns it.

  # Note: this function will be replaced by or moved into Michael's
  # xmlrpc_Marshaller library at some point.

  response = "<value>"
  if type(pythonval) == type(0):
    response += "<int>" + str(pythonval) + "</int>"
  elif type(pythonval) == type(0.1):
    response += "<double>" + str(pythonval) + "</double>"
  elif type(pythonval) == type(True):
    response += "<boolean>" + str(int(pythonval)) + "</boolean>"
  elif type(pythonval) == type(""):
    response += "<string>" + urllib_quote(pythonval) + "</string>"
  elif type(pythonval) == type(xmlrpc_server_Binary()):
    response += "<base64>" + base64_b64encode(pythonval.data) + "</base64>"
  elif type(pythonval) == type([]):
    response += "<array><data>"
    for item in pythonval:
      response += _xmlrpc_server_python_to_xmlvalue(item)
    response += "</data></array>"
  elif type(pythonval) == type({}):
    response += "<struct>"
    for key, val in pythonval.items():
      response += "<member>"
      response += "<name>" + key + "</name>"
      response += _xmlrpc_server_python_to_xmlvalue(val)
      response += "</member>"
    response += "</struct>"

  response += "</value>"
  return response




class xmlrpc_server_ClientError(Exception):
  """Exception raised when the client does something wrong."""
  pass




class xmlrpc_server_ServerError(Exception):
  """Exception raised when the server does something wrong."""
  pass




class xmlrpc_server_SimpleXMLRPCServer:
  """
  <Purpose>
    Provide a simple server-side API for programs wishing to expose their
    functions to an XMLRPC client.

  <Side Effects>
    None.

  <Exceptions>
    ArgumentError if the host part of the address passed to the
    constructor is a hostname that resolves to more than one ip.

  <Example Use>
    # create a server object
    server = xmlrpc_server_SimpleXMLRPCServer(("localhost", 12345))
    # register a function
    server.register_function(pow)
    # wait for clients to connect and call the function
    server.serve_forever()
  """   


  def __init__(self, addr):
    self._listen_ip = _xmlrpc_server_lookup_ip(addr[0])
    self._listen_port = addr[1]

    self._callback_instance = None
    self._callback_functions = {}

    self._listen_comm = None
    self._serverstopped = True
    self._stoplock = getlock()


  def register_function(self, function, name=None):
    """
    <Purpose>
      Register a callback function with this XMLRPC server.

    <Arguments>
      function:
             The function to expose to the XMLRPC client.

      name (optional):
             The name for this function that the client will call. Defaults
             to the name of the function.

    <Exceptions>
      AttributeError if something other than a function is passed and no
      name is given.

    <Side Effects>
      Adds this function to this server's function lookup table.

    <Returns>
      None.
    """

    if name is None:
      name = function.__name__

    self._callback_functions[name] = function


  def register_instance(self, instance):
    """
    <Purpose>
      Register an object with this XMLRPC server.  When the XMLRPC client
      tries to call a function X, the server will first try to call this
      method of instance.

    <Arguments>
      instance:
             The object whose methods are to be exposed to the XMLRPC client.

    <Exceptions>
      None.

    <Side Effects>
      Sets this object as the server's instance. Currently only one instance
      is remembered (calling this method a second time overrides the saved
      instance).

    <Returns>
      None.
    """

    self._callback_instance = instance


  def serve_forever(self):
    """
    <Purpose>
      Serve forever (until someone tells the server to shut down).

    <Arguments>
      None.

    <Exceptions>
      None.

    <Side Effects>
      Starts listening on the host/port this server was created with and
      serving requests.

    <Returns>
      None.
    """

    self._listen_comm = waitforconn(self._listen_ip, self._listen_port, \
        self._connect)

    self._stoplock.acquire()
    self._stopped = False

    # Wait until shutdown() releases the lock.
    self._stoplock.acquire()
    self._stoplock.release()


  def serve_nonblocking(self):    # Better name suggestions are welcome.
    """
    <Purpose>
      Start serving.  Returns control of the thread to the calling code.

    <Arguments>
      None.

    <Exceptions>
      None.

    <Side Effects>
      Starts listening on the host/port this server was created with and
      serving requests.

    <Returns>
      None.
    """

    self._listen_comm = waitforconn(self._listen_ip, self._listen_port, \
        self._connect)

    # Acquire the lock so we don't try to listen in more than one server
    # thread. Also, shutdown() excepts to release the lock.
    self._stoplock.acquire()
    self._stopped = False


  def shutdown(self):
    """
    <Purpose>
      Stop the server.

    <Arguments>
      None.

    <Exceptions>
      None.

    <Side Effects>
      Tells the serving loop to stop.

    <Returns>
      None.
    """

    if not self._stopped:
      self._stoplock.release()
      stopcomm(self._listen_comm)
      self._stopped = True


  def _call_function(self, function_name, args):
    # Call the registered function function_name with the given arguments
    # (args) and return the result.

    if self._callback_instance is not None:
      if hasattr(self._callback_instance, "_dispatch"):
        return self._callback_instance._dispatch(function_name, args)
      try:
        return getattr(self._callback_instance, function_name)(*args)
      except AttributeError:
        # Do nothing, the instance doesn't have the method.  Try the
        # functions instead.
        pass

    if self._callback_functions.has_key(function_name):
      return self._callback_functions[function_name](*args)

    # If we haven't gotten a result yet, the function doesn't exist.
    raise xmlrpc_server_ClientError()


  def _connect(self, remoteip, remoteport, socket, commhandle, listen_commhandle):
    # The callback for client connections.  Handle the request.
    request_data = ""
    while True:
      try:
        more_data = socket.recv(4096)
      except Exception:
        # The client probably disconnected.
        stopcomm(commhandle)
        return

      if len(more_data) == 0:
        break
      request_data += more_data
              # TODO: Grab more data once we have a non-blocking socket
              # interface.
      break   # For now, assume requests are in the first 4kiB

    http_commandline, request_data = request_data.split("\r\n", 1)

    http_command, http_path, http_protocol = http_commandline.split(None, 2)
    if not (http_path == "/RPC2" or http_path == "/") or http_command != "POST":
      raise xmlrpc_server_ClientError()

    # Ignore protocol for now, we'll close connections from HTTP/1.1 clients
    # that want keep-alive for now.

    http_header_text, post_payload = request_data.split("\r\n\r\n", 1)
    
    http_headers = {}
    for line in http_header_text.split("\r\n"):
      header_name, header_value = line.split(": ", 1)
      http_headers[header_name.lower()] = header_value

    xmltree = xmlparse_parse(post_payload)
    if not xmltree.tag_name == "methodCall" or xmltree.children is None:
      raise xmlrpc_server_ClientError()

    # Find the method name in the xml tree of the POST payload.
    methodname = None
    for childtag in xmltree.children:
      if childtag.tag_name == "methodName":
        if childtag.content is None:
          raise xmlrpc_server_ClientError()
        methodname = childtag.content
        break

    if methodname is None:
      raise xmlrpc_server_ClientError()

    # Find the <params> element of the xml tree.
    paramxmlnodes = None
    for childtag in xmltree.children:
      if childtag.tag_name == "params":
        paramxmlnodes = childtag.children
        break

    # Make a list of the parameters to the method call.
    params = []
    if paramxmlnodes is not None:
      for paramnode in paramxmlnodes:
        if paramnode.tag_name != "param" or paramnode.children is None or \
            len(paramnode.children) != 1:
          raise xmlrpc_server_ClientError()
        params.append(_xmlrpc_server_valuenode_to_python(paramnode.children[0]))

    # Make the method call, get the result.
    result = self._call_function(methodname, params)

    # Encode the result and send it back to the client.
    xmlresponse = _xmlrpc_server_python_to_xmlvalue(result)
    xmlresponse = "<?xml version='1.0'?>\r\n<methodResponse>\r\n" + \
        "<params>\r\n<param>\r\n" + xmlresponse + "\r\n</param>\r\n" + \
        "</params>\r\n</methodResponse>"

    response = "HTTP/1.0 200 OK\r\nServer: SimpleXMLRPCServer on Repy\r\n" + \
      "Content-type: text/xml\r\nContent-length: %i\r\n\r\n%s" % \
      (len(xmlresponse), xmlresponse)

    while True:
      sent = socket.send(response)
      if sent >= len(response):
        break
      response = response[sent:]

    stopcomm(commhandle)
