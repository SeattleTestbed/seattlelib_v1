"""
<Program Name>
  time.repy

<Author>
  Eric Kimbrel

<Started>
  Jul 2, 2009

<Purpose>
  Provide a framework to run any implementation of a ntp time service that
  follows the interface provided here.

  Any implementation must provide update method that takes a localport 
  as an argument.

  Implementers will set a mapping to their functions by adding a line
  at the BOTTOM of their implementation, such as 
  TIME_IMP_DICT['my_implementation'] = {'update':update_func}. This forms a sort
  of "nested dictionary" where the highest level contains keys to all of the
  implementations, and the values for the implementation keys are themselves
  dictionaries containing the names of all the functions linked to that
  that implementation which can be used for replacing regular or default
  functions.

  USE:
  
  To use this module, first make a call to time_updatetime(localport),where
  localport is a valid UDP port that you can send and receive on (note that
  this port may not be used depending on the implementation.)

  Then, to get the actual time, call time_gettime() which will return
  the current time (in seconds).

  ADVANCED USE:

  If you want to explicitly set how time.repy will execute you can use
  time_set_pref(pref_list) to override the default values.  Miss use of
  this feature can easily cause unexpected / undefined behavior

"""


# dictionary for time implementers to store their information
# the settime method is passed in for use by implementers
# this is nessicary to make time.repy work with repyhelper
mycontext['TIME_IMP_DICT'] = {}

# include implementations
include ntp_time.repy
include tcp_time.repy



# set the order of preferences for time layers
# this is set by default to use ntp_time.repy and the tcp_time.repy
TIME_PREF = ['ntp','tcp']


time_query_times = []


def time_set_pref(new_pref_list):
# for advanced use only
# manually set the layers to be used
  
  # empty the current list
  while (len(TIME_PREF) >0):
    TIME_PREF.pop()

  # refill the list with custom preferences
  for pref in new_pref_list:
    TIME_PREF.append(pref)



def time_updatetime(localport):
  """
   <Purpose>
    Obtains and stores the local time from a subset of NTP servers.

   <Arguments>
    localport:
             The local port that MAY be used when contacting the NTP server(s).
             Consider this port a hint and not a rule.
   
   <Exceptions>
    TimeError when getmyip() fails or one of the subset of NTP servers will not
    respond.

   <Side Effects>
    time_settime(currenttime) is called as the sub process of a sub process,
    which adjusts the current time.

   <Returns>
    None.
  """
  exception_list = []
  # try the 'update' function for each implementation, storing exceptions in
  # case of total failure, and exiting the function when any of the 'update'
  # functions succeed.
  for imp in TIME_PREF:
    try:
      mycontext['TIME_IMP_DICT'][imp]['update'](localport)
    except Exception, e:
      exception_list.append(e)
    else:
      return  # exit when we succeed

  # we failed
  ex_str =''
  for ex in exception_list:
    ex_str+=str(ex)
  ex_str = 'ERROR: failed to update ntp time, '+ex_str
  raise Exception(ex_str)





def time_settime(currenttime):
  """
   <Purpose>
    Sets a remote time as the current time.

   <Arguments>
    currenttime:
               The remote time to be set as the current time.

   <Exceptions>
    None.

   <Side Effects>
    Adjusts the current time.

   <Returns>
    None.
  """

  time_query_times.append((getruntime(), currenttime))






def time_gettime():
  """
   <Purpose>
    Gives the current time in seconds by calculating how much time has elapsed
    since the local time was obtained from an NTP server via the
    time_updatetime(localport) function.

   <Arguments>
    None.

   <Exceptions>
    TimeError when time_updatetime(localport)has not previously been called or 
    when time_updatetime(localport) has any unresolved TimeError exceptions.

   <Side Effects>
    None.

   <Returns>
    Current time in seconds.
  """

  if time_query_times == []:
    raise TimeError

  # otherwise use the most recent data...
  latest_update = time_query_times[-1]

  # first item is the getruntime(), second is NTP time...
  elapsedtimesinceupdate = getruntime() - latest_update[0]

  return latest_update[1] + elapsedtimesinceupdate



# in case you want to change to time since the 1970 (as is common)
time_seconds_from_1900_to_1970 = 2208988800


# pass the time_settime method into the TIME_IMP_DICT for
# use by implementers
mycontext['TIME_IMP_DICT']['time'] = {'set':time_settime}
