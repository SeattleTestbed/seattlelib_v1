"""
<Description>
  A socket that doesn't hang.   Closes after a given timeout.

<Usage>
  Same as Repy Sockets:
    openconn(desthost, destport, localip=None, localport=None, timeout = 5)
    waitforconn(localip, localport, function)
    stopcomm(sockobj)

  Object:
    sockobj.send(data)
    sockobj.recv(bytes)

<Date>
  Sun Mar  1 10:27:35 PST 2009

<Example>
  # hello world
  include sockettimer.repy

  def callback(ip, port, sockobj, commhandle, listenhandle):
    hw_message =sockobj.recv(1047)
    stopcomm(sockobj)
    stopcomm(listenhandle)
    print hw_message # => "hello world!"
  
  def server():
    sockobj = waitforconn(getmyip(), 12345, callback)

  def client():
    sockobj = openconn(getmyip(), 12345)
    sockobj.send("hello world!")

  def main():
    server()
    client()
    exitall()

  if callfunc == 'initialize':
    main() 
"""

class TimeoutError(Exception):
  """The socket timed out before receiving a response"""

def openconn(desthost, destport, localip=None, localport=None, timeout = 5): pass

def waitforconn(localip, localport, function): pass

def stopcomm(sockobj): pass


class TimeoutSocket():
  """
  <Purpose>
    Provide an socket object like the Repy usual one.

  <Side Effects>
    Uses a getlock() to watch for a timeout
  """

  def __init__(self):
    self.lock = getlock()

  def recv(self, maxLen): pass

  def send(self, data): pass



# private function...
def sockettimeout_clobbersocket(sockobj,mylock):
  # if I can acquire the lock without blocking, then close the socket to abort
  if mylock.acquire(False):
    sockobj.close()

# if it fails to finish within the timeout, I close the socket and raise a
# SocketTimeout exception...
def sockettimeout_recv_or_close(sockobj, amount, timeout):
  # A lock I'll use for this attempt
  mylock = getlock()
  timerhandle = settimer(timeout,clobbersocket, (sockobj, mylock))
  try:
    retdata = sockobj.recv(amount)
  except Exception, e:
    # if it's not the timeout, reraise...
    if mylock.acquire(False):
      raise
    raise SocketTimeout
    
  # I acquired the lock, I should stop the timer because I succeeded...
  if mylock.acquire(False):
    # even if this isn't in time, the lock prevents a race condition 
    # this is merely an optimization to prevent the timer from ever firing...
    canceltimer(timerhandle)
    return retdata
  else:
    raise SocketTimeout

