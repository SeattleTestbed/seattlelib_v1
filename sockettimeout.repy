"""
<Author>
  Justin Cappos
  This is a rewrite of the previous version by Richard Jordan

<Start Date>
  26 Aug 2009

<Description>
  A library that causes sockets to timeout if a recv / send call would
  block for more than an allotted amount of time.

"""


class SocketTimeoutError(Exception):
  """The socket timed out before receiving a response"""


class _timeout_socketlikeobject:
  """
  <Purpose>
    Provide an socket object like the Repy usual one.

  <Side Effects>
    Uses a getlock() to watch for a timeout
    Uses waitforconn and openconn to simulate socket
  """
  
  # This is the socket like object we're using underneath
  underlying_socketlikeobject = None
  
  # This will be the commhandle when the socket was created through
  # _timeout_waitforconn_callback. This will remain None for sockets created
  # through timeout_openconn.
  commhandle = None

  # The amount of time to wait for a timeout...
  timeout = None

  # The exception to raise.   This is needed because the thread that is timing
  # out the connection may want to raise a specific exception
  send_exception = None
  recv_exception = None

  def __init__(self, givensocketlikeobject, giventimeout, commhandle=None):
    self.underlying_socketlikeobject = givensocketlikeobject
    self.timeout = giventimeout
    self.commhandle = commhandle


  def recv(self, maxamount):
    """
    <Purpose>
      If it fails to finish within the timeout, I close the socket and raise a
      SocketTimeoutError exception. I.e. if there's no message, we call it an 
      error and raise it.   
      
    <Arguments>
      maxamount - maximum number of bytes to recv

    <Exception>
      Raises SocketTimeoutError exception if the recv times out
      without receiving a message.

    <Side Effects>
      Closes the connection if times out.   Starts a thread to close after
      the connection times out.

    <Returns>
      The message.
    """

    # get a lock used for this call...
    thiscalllock = getlock()
    timerhandle = settimer(self.timeout, self._close_if_lock_is_acquired, (thiscalllock,))

    try:
      retdata = self.underlying_socketlikeobject.recv(maxamount)
    except Exception, e:
      # if it's not the timeout, reraise, otherwise it's a timeout...

      # There is a benign race condition here between a call that fails from
      # another error at the last moment, but the socket timeout grabs the 
      # lock before it is reported.
      if thiscalllock.acquire(False):
        raise
      raise SocketTimeoutError("Socket Timeout ('"+str(e)+"')")
    
    # I acquired the lock, I should stop the timer because I succeeded...
    if thiscalllock.acquire(False):
      # even if this isn't in time, the lock prevents a race condition 
      # this is merely an optimization to prevent the timer from ever firing...
      canceltimer(timerhandle)
      return retdata
    else:
      raise SocketTimeoutError("Socket Timeout")



  def send(self, data):
    """
    <Purpose>
      If send fails to finish within the timeout, I close the socket and raise 
      a Socket TimeoutError exception.   I.e. if the receiver hasn't called
      recv and their buffer is full after a singificant amount of time, we 
      raise an error.
      
    <Arguments>
      data - the string to send

    <Exception>
      Raises SocketTimeoutError exception if the send times out.

    <Side Effects>
      Closes the connection if times out.   Starts a thread to close after
      the connection times out.

    <Returns>
      The message.
    """

    # get a lock used for this call...
    thiscalllock = getlock()
    timerhandle = settimer(self.timeout, self._close_if_lock_is_acquired, (thiscalllock,))

    try:
      retdata = self.underlying_socketlikeobject.send(data)
    except Exception, e:
      # if it's not the timeout, reraise, otherwise it's a timeout...

      # There is a benign race condition here between a call that fails from
      # another error at the last moment, but the socket timeout grabs the 
      # lock before it is reported.
      if thiscalllock.acquire(False):
        raise
      raise SocketTimeoutError("Socket Timeout ('"+str(e)+"')")
    
    # I acquired the lock, I should stop the timer because I succeeded...
    if thiscalllock.acquire(False):
      # even if this isn't in time, the lock prevents a race condition 
      # this is merely an optimization to prevent the timer from ever firing...
      canceltimer(timerhandle)
      return retdata
    else:
      raise SocketTimeoutError("Socket Timeout")



  def close(self):
    """
      Identical to socket.close()
    """
    # Socket-like objects created through calls to timeout_openconn don't have
    # a commhandle like the ones created through waitforconn callback calls.
    if self.commhandle is None:
      return self.underlying_socketlikeobject.close()
    else:
      return timeout_stopcomm(self.commhandle)



  # A helper that is used by send and recv
  def _close_if_lock_is_acquired(self,thiscalllock):
    """
    <Purpose>
      Call close if a lock can be acquired.   A helper for timeout
      
    <Arguments>
      The lock to use

    <Exceptions>
      None.   This will be called in a separate event and should not raise
      an exception.
  
    <Side Effects>
      Closes the connection if the lock is acquired.
    
    <Returns>
      None.
    """
    # close if I get the lock, else do nothing.
    if thiscalllock.acquire(False):
      self.close()
      
 
  


def timeout_openconn(desthost, destport, localip=None, localport=None, timeout=5):
  """
  <Purpose> 
    Wrapper for openconn.   Very, very similar

  <Args>
    Same as Repy openconn

  <Exception>
    Raises the same exceptions as openconn.

  <Side Effects>
    Creates a socket object for the user

  <Returns>
    socket obj on success
  """

  realsocketlikeobject = openconn(desthost, destport, localip, localport, timeout)

  thissocketlikeobject = _timeout_socketlikeobject(realsocketlikeobject, timeout)
  return thissocketlikeobject





def timeout_waitforconn(localip, localport, function, timeout=5):
  """
  <Purpose> 
    Wrapper for waitforconn.   Essentially does the same thing...

  <Args>
    Same as Repy waitforconn with the addition of a timeout argument.

  <Exceptions> 
    Same as Repy waitforconn

  <Side Effects>
    Sets up event listener which calls function on messages.

  <Returns>
    Handle to listener.
  """

  # We use a closure for the callback we pass to waitforconn so that we don't
  # have to map mainch's to callback functions or deal with potential race
  # conditions if we did maintain such a mapping. 
  def _timeout_waitforconn_callback(localip, localport, sockobj, ch, mainch):
    # 'timeout' is the free variable 'timeout' that was the argument to
    #  timeout_waitforconn.
    thissocketlikeobject = _timeout_socketlikeobject(sockobj, timeout, ch)

    # 'function' is the free variable 'function' that was the argument to
    #  timeout_waitforconn.
    return function(localip, localport, thissocketlikeobject, ch, mainch)

  return waitforconn(localip, localport, _timeout_waitforconn_callback)

  
  


# a wrapper for stopcomm
def timeout_stopcomm(commhandle):
  """
    Wrapper for stopcomm.   Does the same thing...
  """

  return stopcomm(commhandle)
  
    

