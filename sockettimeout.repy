"""
<Author>
  Justin Cappos
  This is a rewrite of the previous version by Richard Jordan

<Start Date>
  26 Aug 2009

<Description>
  A library that causes sockets to timeout if a recv / send call would
  block for more than an allotted amount of time.

"""


class SocketTimeoutError(Exception):
  """The socket timed out before receiving a response"""


class _timeout_socketlikeobject:
  """
  <Purpose>
    Provide an socket object like the Repy usual one.

  <Side Effects>
    Uses a getlock() to watch for a timeout
    Uses waitforconn and openconn to simulate socket
  """
  
  # This is the socket like object we're using underneath
  underlying_socketlikeobject = None

  # The amount of time to wait for a timeout...
  timeout = None

  # The exception to raise.   This is needed because the thread that is timing
  # out the connection may want to raise a specific exception
  send_exception = None
  recv_exception = None

  def __init__(self, givensocketlikeobject, giventimeout):
    self.underlying_socketlikeobject = givensocketlikeobject
    self.timeout = giventimeout


  def recv(self, maxamount): # timeout as optional arg ???
    """
    <Purpose>
      If it fails to finish within the timeout, I close the socket and raise a
      SocketTimeoutError exception. I.e. if there's no message, we call it an 
      error and raise it.   
      
    <Arguments>
      maxamount - maximum number of bytes to recv

    <Exception>
      Raises SocketTimeoutError exception if the recv times out
      without receiving a message.

    <Side Effects>
      Closes the connection if times out.   Starts a thread to close after
      the connection times out.

    <Returns>
      The message.
    """

    # get a lock used for this call...
    thiscalllock = getlock()
    timerhandle = settimer(self.timeout, self._close_if_lock_is_acquired, (thiscalllock,))

    try:
      retdata = self.underlying_socketlikeobject.recv(maxamount)
    except Exception, e:
      # if it's not the timeout, reraise, otherwise it's a timeout...

      # There is a benign race condition here between a call that fails from
      # another error at the last moment, but the socket timeout grabs the 
      # lock before it is reported.
      if thiscalllock.acquire(False):
        raise
      raise SocketTimeoutError("Socket Timeout ('"+str(e)+"')")
    
    # I acquired the lock, I should stop the timer because I succeeded...
    if thiscalllock.acquire(False):
      # even if this isn't in time, the lock prevents a race condition 
      # this is merely an optimization to prevent the timer from ever firing...
      canceltimer(timerhandle)
      return retdata
    else:
      raise SocketTimeoutError("Socket Timeout")



  def send(self, data):
    """
    <Purpose>
      If send fails to finish within the timeout, I close the socket and raise 
      a Socket TimeoutError exception.   I.e. if the receiver hasn't called
      recv and their buffer is full after a singificant amount of time, we 
      raise an error.
      
    <Arguments>
      data - the string to send

    <Exception>
      Raises SocketTimeoutError exception if the send times out.

    <Side Effects>
      Closes the connection if times out.   Starts a thread to close after
      the connection times out.

    <Returns>
      The message.
    """

    # get a lock used for this call...
    thiscalllock = getlock()
    timerhandle = settimer(self.timeout, self._close_if_lock_is_acquired, (thiscalllock,))

    try:
      retdata = self.underlying_socketlikeobject.send(data)
    except Exception, e:
      # if it's not the timeout, reraise, otherwise it's a timeout...

      # There is a benign race condition here between a call that fails from
      # another error at the last moment, but the socket timeout grabs the 
      # lock before it is reported.
      if thiscalllock.acquire(False):
        raise
      raise SocketTimeoutError("Socket Timeout ('"+str(e)+"')")
    
    # I acquired the lock, I should stop the timer because I succeeded...
    if thiscalllock.acquire(False):
      # even if this isn't in time, the lock prevents a race condition 
      # this is merely an optimization to prevent the timer from ever firing...
      canceltimer(timerhandle)
      return retdata
    else:
      raise SocketTimeoutError("Socket Timeout")




  def close(self):
    """
      Identical to socket.close()
    """
    return self.underlying_socketlikeobject.close()



  # A helper that is used by send and recv
  def _close_if_lock_is_acquired(self,thiscalllock):
    """
    <Purpose>
      Call close if a lock can be acquired.   A helper for timeout
      
    <Arguments>
      The lock to use

    <Exceptions>
      None.   This will be called in a separate event and should not raise
      an exception.
  
    <Side Effects>
      Closes the connection if the lock is acquired.
    
    <Returns>
      None.
    """
    # close if I get the lock, else do nothing.
    if thiscalllock.acquire(False):
      self.close()
 
  


def timeout_openconn(desthost, destport, localip=None, localport=None, timeout = 5):
  """
  <Purpose> 
    Wrapper for openconn.   Very, very similar

  <Args>
    Same as Repy openconn

  <Exception>
    Raises the same exceptions as openconn.

  <Side Effects>
    Creates a socket object for the user

  <Returns>
    socket obj on success
  """

  realsocketlikeobject = openconn(desthost, destport, localip, localport, timeout)

  thissocketlikeobject = _timeout_socketlikeobject(realsocketlikeobject, timeout)
  return thissocketlikeobject


# This maps commhandles to their callback function
# NOTE: I never clean this up.   I probably should, but I'm concerned about
# the potential for a race condition
_timeout_mainch_to_function_dict = {}

def timeout_waitforconn(localip, localport, function):
  """
  <Purpose> 
    Wrapper for waitforconn.   Essentially does the same thing...

  <Args>
    Same as Repy waitforconn

  <Exceptions> 
    Same as Repy waitforconn

  <Side Effects>
    Sets up event listener which calls function on messages.

  <Returns>
    Handle to listener.
  """

  mainch = waitforconn(localip,localport,_timeout_waitforconn_callback)
  _timeout_mainch_to_function_dict[mainch] = function
  return mainch


# this holds the commhandles that are needed by stopcomm.   We essentially
# just store the info here so we know how handles are associated.
_timeout_commhandle_to_socket_dict = {}

def _timeout_waitforconn_callback(localip, localport, sockobj, ch, mainch):
  defaulttimeout = 5
  thissocketlikeobject = _timeout_socketlikeobject(sockobj, defaulttimeout)
  _timeout_commhandle_to_socket_dict[ch] = thissocketlikeobject

  # JAC: There is a possibility for a race here, but it's very, very unlikely.
  # It would need the waitforconn to hang, but the callback to proceed.
  function = _timeout_mainch_to_function_dict[mainch]

  # I'm not remapping the commhandles...
  return function(localip, localport, thissocketlikeobject, ch, mainch)
  
  


# a wrapper for stopcomm
def timeout_stopcomm(commhandle):
  """
    Wrapper for stopcomm.   Does the same thing...
  """

  if commhandle in _timeout_commhandle_to_socket_dict:
    # I should close locally and remove the entry...
    _timeout_commhandle_to_socket_dict[commhandle].close()
    del _timeout_commhandle_to_socket_dict[commhandle]
    return True

  return stopcomm(commhandle)
  
    

