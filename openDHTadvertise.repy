"""
Author: Justin Cappos

Start Date: July 8, 2008

Description:
Advertises availability to openDHT...

This code is partially adapted from the example openDHT code.

"""

include random.repy
include sha.repy
include xmlrpc_client.repy


mycontext["proxylist"] = []
mycontext["currentproxy"] = None
mycontext["serverlist"] = []
mycontext["serverlistlock"] = getlock()

def openDHTadvertise_announce(key, value, ttlval):
  """
  <Purpose>
    Announce a (key, value) pair to openDHT.

  <Arguments>
    key:
            The new key the value should be stored under.

    value:
            The value to associate with the given key.

    ttlval:
            The length of time (in seconds) to persist this key <-> value
            association in DHT.

  <Exceptions>
    Exception if the xmlrpc server behaves erratically.

  <Side Effects>
    The key <-> value association gets stored in openDHT for a while.

  <Returns>
    None.
  """

  # JAC: Copy value because it seems that Python may otherwise garbage collect
  # it in some circumstances.   This seems to fix the problem
  value = str(value)[:]

  # convert ttl to an int
  ttl = int(ttlval)

#  print "Announce key:",key,"value:",value, "ttl:",ttl
  while True:
    # if we have an empty proxy list and no proxy, get more
    if mycontext["currentproxy"] == None and mycontext["proxylist"] == []:
      mycontext["proxylist"] = openDHTadvertise_get_proxy_list()
      # we couldn't get any proxies
      if mycontext["proxylist"] == []:
        return False


    # if there isn't a proxy we should use, get one from our list
    if mycontext["currentproxy"] == None and mycontext["proxylist"] != []:
      mycontext["currentproxy"] = mycontext["proxylist"][0]
      del mycontext["proxylist"][0]


    # This code block is adopted from put.py from OpenDHT
    pxy = xmlrpc_client_Client(mycontext["currentproxy"])
    keytosend = xmlrpc_common_Binary(sha_new(str(key)).digest())
    valtosend = xmlrpc_common_Binary(value)

    try:
      pxy.send_request("put", (keytosend, valtosend, ttl, "put.py"))
      # if there isn't an exception, we succeeded
      break
    except xmlrpc_common_ConnectionError:
      # Let's avoid this proxy.   It seems broken
      mycontext["currentproxy"] = None

  return True




def openDHTadvertise_lookup(key, maxvals=100):
  """
  <Purpose>
    Retrieve a stored value from openDHT.

  <Arguments>
    key:
            The key the value is stored under.

    maxvals:
            The maximum number of values stored under this key to
            return to the caller.

  <Exceptions>
    Exception if the xmlrpc server behaves erratically.

  <Side Effects>
    None.

  <Returns>
    The value stored in openDHT at key.
  """

  while True:
    # if we have an empty proxy list and no proxy, get more
    if mycontext["currentproxy"] == None and mycontext["proxylist"] == []:
      mycontext["proxylist"] = openDHTadvertise_get_proxy_list()
      # we couldn't get any proxies
      if mycontext["proxylist"] == []:
        raise Exception, "Lookup failed"


    # if there isn't a proxy we should use, get one from our list
    if mycontext["currentproxy"] == None and mycontext["proxylist"] != []:
      mycontext["currentproxy"] = mycontext["proxylist"][0]
      del mycontext["proxylist"][0]


    # This code block is adopted from get.py from OpenDHT
    pxy = xmlrpc_client_Client(mycontext["currentproxy"])
    maxvalhash = int(maxvals)
    # I don't know what pm is for but I assume it's some sort of generator / 
    # running counter
    pm = xmlrpc_common_Binary("")
    keyhash = xmlrpc_common_Binary(sha_new(str(key)).digest())


    listofitems = []
    # If the proxy fails, then we will go to the next one...
    while mycontext["currentproxy"]:
      try:
        try:
          vals, pm = pxy.send_request("get", (keyhash, maxvalhash, pm, "get.py"))
        except xmlrpc_common_XMLParseError, e:
          raise Exception, e
        # if there isn't an exception, we succeeded

        # append the .data part of the items, the other bits are:
        # the ttl and hash / hash algorithm.
        for item in vals:
          listofitems.append(item.data)

        # reached the last item.  We're done!
        if pm.data == "":
          return listofitems

      except xmlrpc_common_ConnectionError:
        # Let's avoid this proxy.   It seems broken
        mycontext["currentproxy"] = None




# check to see if a server is up and ready for OpenDHT...
class openDHTadvertise_ServerTest:
  def __init__(self, servername):
    self.servername = servername

    # The thread takes this lock as soon as it is started; it releases it
    # when the thread finishes. I am using it to implement join().
    self._runlock = getlock()
    self._used = False

  def run(self):
    try:
      # try three times.   Why three?   Arbitrary value
      for junkcount in range(3):
        s = openconn(self.servername, 5851, timeout=2.0)
        s.close()

      # this list is the "return value".   Add ourselves if no problems...
      mycontext["serverlistlock"].acquire()
      try:
        mycontext["serverlist"].append(self.servername)
      finally:
        mycontext["serverlistlock"].release()
    except:
      pass
    finally:
      self._runlock.release()

  def start(self):
    if self._used:
      raise Exception("Threads may only be started once")
    self._used = True
    self._runlock.acquire()
    settimer(0, self.run, ())

  def join(self):
    self._runlock.acquire()
    self._runlock.release()


# Loosely based on find-gateway.py from the OpenDHT project...
def openDHTadvertise_get_proxy_list(maxnumberofattempts=30):
  """
  <Purpose>
    Gets a list of active openDHT proxies.

  <Arguments>
    maxnumberofattemps:
           Maximum number of servers to attempt to connect to.

  <Exceptions>
    Exception if there are no servers in the server list.

  <Side Effects>
    Tries to connect to several proxies to see if they are online.

  <Returns>
    A list of openDHT approxies that appear to be up.
  """

  # populate server list
  socket = openconn('opendht.org', 80)
  socket.send("GET /servers.txt HTTP/1.0\r\nHost: opendht.org\r\n\r\n")
  
  body = ""
  while True:
    try:
      newdata = socket.recv(4096)
    except:
      # Server decided it is done.
      break
    if len(newdata) == 0:
      break   # Server finished sending us the response.
    body += newdata

  headers, payload = body.split("\r\n\r\n", 1)
  lines = payload.split("\n")
  # throw away the header line
  lines = lines[1:]
  # get the server list
  servers = []
  for line in lines:
    if line.strip() == "":
      continue
    # The lines look like:
    # 4:	134.121.64.7:5850	planetlab2.eecs.wsu.edu
    # The third field is the server name
    servers.append(line.split()[2])

  if len(servers) == 0:
    raise Exception, "No servers in server list"

  numberofattempts = min(len(servers), maxnumberofattempts)
  serverstocheck = random_sample(servers, numberofattempts)

  serverthreads = []
  for server in serverstocheck:
    serverthreads.append(openDHTadvertise_ServerTest(server))


  # empty the server list
  mycontext["serverlist"] = []

  # start checking...
  for thread in serverthreads:
    thread.start()

  # wait until all are finished
  for thread in serverthreads:
    thread.join()


  retlist = []
  for serverip in mycontext["serverlist"]:
    # make it look like the right sort of url...
    retlist.append("http://"+serverip+":5851/")


  return retlist
