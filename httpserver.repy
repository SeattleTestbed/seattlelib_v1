"""
<Program Name>
  httpserver.repy

<Started>
  July 29, 2009

<Author>
  Yafete Yemuru
  Conrad Meyer

<Purpose>
  This is a library that abstracts away the details of the HTTP protocol,
  instead calling a user-supplied function on each request. The return
  value of the user-supplied function determines the response that is sent
  to the HTTP client.

"""



include urllib.repy
include urlparse.repy
include uniqueid.repy
include sockettimeout.repy
include httpretrieve.repy




class _httpserver_ClientClosedSockEarly(Exception):
  # Raised internally when the client unexpectedly closes the socket. The
  # correct behavior in this instance is to clean up that handler and
  # continue.
  pass




class _httpserver_BadRequest(Exception):
  # Raised internally when the client's request is malformed.
  pass




class _httpserver_ServerError(Exception):
  # Raised internally when the callback function unexpectedly raises an
  # exception.
  pass




class _httpserver_BadTransferCoding(Exception):
  # Raised internally when the request's encoding is something we can't
  # handle (most everything at the time of writing).
  pass




_httpserver_context = {
    'handles': {},
    'cbfuncs': {},
    'lock': getlock()}



def httpserver_registercallback(socket, cbfunc):
  """
  <Purpose>
    Registers a callback function on the socket.

  <Arguments>
    socket:
      A socket 2-tuple to bind to: ('host', port).

    cbfunc:
      The callback function to process requests. It takes one argument,
      which is a dictionary describing the HTTP request. It looks like
      this (just an example):
        {
          'verb': 'HEAD',
          'path': '/',
          'querystr': 'foo=bar&baz',
          'querydict': { 'foo': 'bar', 'baz': None }
          'version': '0.9',
          'poststr': 'BAR',
          'postdict': { 'BAR': None },
          'headers': { 'Content-Type': 'application/x-xmlrpc-data'}
        }

      It is expected that this callback function returns a dictionary of:
        {
          'version': '0.9' or '1.0' or '1.1',
          'statuscode': any integer from 100 to 599,
          'statusmsg' (optional): an arbitrary string without newlines,
          'headers': { 'X-Header-Foo': 'Bar' },
          'message': arbitrary string
        }

  <Exceptions>
    TypeError, ValueError, KeyError, IndexError if arguments to this
    function are malformed.

  <Side Effects>
    Starts a listener on the given host and port.

  <Returns>
    A handle for the listener. This can be used to stop the server.

  """

  _httpserver_context['lock'].acquire()

  try:
    newhttpdid = uniqueid_getid()

    # Keep track of this server's id in a closure:
    def _httpserver_cbclosure(remoteip, remoteport, sock, ch, listench):
      _httpserver_socketcb(remoteip, remoteport, sock, ch, listench, \
          newhttpdid)

    _httpserver_context['handles'][newhttpdid] = \
        waitforconn(socket[0], socket[1], _httpserver_cbclosure)
    _httpserver_context['cbfuncs'][newhttpdid] = cbfunc

    return newhttpdid
  finally:
    _httpserver_context['lock'].release()




def _httpserver_socketcb(remoteip, remoteport, sock, ch, listench, httpdid):
  # This function gets invoked each time a client connects to our socket.

  # It proceeds in a loop -- reading in requests, handing them off to the
  # callback function, and sending the result to the client. If errors are
  # encountered, it sends an error message (we choose HTTP/1.0 for
  # compatibility and because we don't always know what version the client
  # wants) and closes the connection. Additionally, if the response
  # generated by the callback requests protocol version 0.9 or 1.0, or is
  # 1.1 but includes the Connection: close header, the connection is closed
  # and the loop broken.

  _httpserver_context['lock'].acquire()
  try:
    cbfunc = _httpserver_context['cbfuncs'][httpdid]
  finally:
    _httpserver_context['lock'].release()

  extradata = ""

  while True:
    try:
      # Read HTTP request off the socket
      headerdata, extradata = _httpserver_readHTTPheader(sock, extradata)
      reqinfo = _httpserver_parseHTTPheader(headerdata)
      messagebody, extradata = _httpserver_getHTTPbody(sock, extradata, \
          reqinfo['verb'], reqinfo['headers'])

      # Try and decode POSTed form data
      reqinfo['poststr'] = messagebody
      try:
        reqinfo['postdict'] = urllib_unquote_parameters(messagebody)
      except:
        reqinfo['postdict'] = None

      # Send request to callback
      try:
        result = cbfunc(reqinfo)
      except Exception, e:
        raise _httpserver_ServerError("httpserver: Callback function " + \
            "raised an exception: " + str(e))

      # Interpret result of callback function
      try:
        version = result['version']
        statuscode = result['statuscode']
        statusmsg = result['statusmsg']
        headers = result['headers']
        message = result['message']
      except:
        raise _httpserver_ServerError("httpserver: Callback function " + \
            "returned malformed dictionary")

      if reqinfo['version'] == "1.0" and version == "1.1":
        version = "1.0"

      # Send response as instructed by callback
      if version == "0.9":
        # HTTP/0.9 doesn't have response headers.
        _httpserver_sendAll(sock, message, besteffort=True)
        break
      elif version == "1.0":
        response = "HTTP/1.0 " + str(statuscode) + " " + statusmsg + "\r\n"
        for key, val in headers.items():
          response += key + ": " + val + "\r\n"
        response += "\r\n"
        response += message
        _httpserver_sendAll(sock, response, besteffort=True)
        break
      elif version == "1.1":
        response = "HTTP/1.1 " + str(statuscode) + " " + statusmsg + "\r\n"
        for key, val in headers.items():
          response += key + ": " + val + "\r\n"
        if "Content-Length" not in headers:
          response += "Content-Length: %d\r\n" % len(message)
        response += "\r\n"
        response += message
        try:
          _httpserver_sendAll(sock, response)
          if ("Connection" in headers and "close" == headers["Connection"]) \
              or ("Connection" in reqinfo['headers'] and "close" in \
              reqinfo['headers']["Connection"]):
                break
        except:
          break
      else:
        raise _httpserver_ServerError("httpserver: Callback function gave " + \
            "invalid HTTP version")

    except _httpserver_BadRequest, br:
      response = "HTTP/1.0 400 Bad Request\r\n" + \
          "Content-Type: text/plain\r\n\r\n" + str(br) + "\r\n"
      _httpserver_sendAll(sock, response, besteffort=True)
      break
    
    except _httpserver_ServerError, se:
      response = "HTTP/1.0 500 Internal Server Error\r\n" + \
          "Content-Type: text/plain\r\n\r\n" + str(se) + "\r\n"
      _httpserver_sendAll(sock, response, besteffort=True)
      break
    
    except _httpserver_BadTransferCoding, bte:
      response = "HTTP/1.1 501 Not Implemented\r\n" + \
          ("Content-Length: %d\r\n" % (len(str(bte)) + 2)) + \
          "Connection: close\r\n" + \
          "Content-Type: text/plain\r\n\r\n" + str(bte) + "\r\n"
      _httpserver_sendAll(sock, response, besteffort=True)
      break

    except _httpserver_ClientClosedSockEarly:
      # Not much else we can do.
      break
    
    except Exception, e:
      if "Socket closed" in str(e):
        break
      raise

      # Any other error? Disconnect and quit.
      break

  # After while loop is done, close the socket.
  try:
    sock.close()
  except:
    pass #don't care




def _httpserver_readHTTPheader(sock, data):
  # Reads data from the socket in 4k chunks, replacing \r\n newlines with
  # \n newlines. When it encounters a (decoded) \n\n sequence, it returns
  # (data_before, data_after).

  headers = []
  command = True
  while True:
    line, data = _httpserver_getline(sock, data)
    if len(line) == 0:
      raise _httpserver_ClientClosedSockEarly()

    # Be a well-behaved server, and handle normal newlines and telnet-style
    # newlines in the same fashion.
    line = line.rstrip("\r")
    if command:
      splitln = line.split(" ", 2)
      if len(splitln) < 3:
        raise _httpserver_BadRequest("HTTP/0.9 or malformed request.")
      command = False

    if len(line) == 0:
      break

    headers.append(line)

  return (headers, data)




def _httpserver_parseHTTPheader(headerdata):
  lines = headerdata
  command = lines[0]
  otherheaders = lines[1:]

  infodict = {}

  verb, rawpath, version = command.split(" ", 2)
  
  infodict['verb'] = verb

  if len(version) != len("HTTP/1.1"):
    raise _httpserver_BadRequest("Bad HTTP command")
  version = version.upper()
  if version == "HTTP/1.0":
    infodict['version'] = '1.0'
  elif version == "HTTP/1.1":
    infodict['version'] = '1.1'
  else:
    raise _httpserver_BadRequest("Unrecognized HTTP version")

  if rawpath.find("?") != -1:
    infodict['path'], infodict['querystr'] = rawpath.split("?", 1)
  else:
    infodict['path'] = rawpath
    infodict['querystr'] = None

  try:
    infodict['headers'] = _httpretrieve_parse_responseheaders(otherheaders)
  except HttpBrokenServerError:
    raise _httpserver_BadRequest("Request headers are misformed.")

  try:
    infodict['querydict'] = urllib_unquote_parameters(infodict['querystr'])
  except:
    infodict['querydict'] = None

  return infodict
    




def _httpserver_sendAll(sock, data, besteffort=False):
  # Sends all the data to sock. If besteffort is True,
  # we don't care if it fails or not.
  try:
    while len(data) > 0:
      data = data[sock.send(data):]
  except:
    if not besteffort:
      raise




def _httpserver_getHTTPbody(sock, data, verb, headers):
  # Reads the rest of the HTTP request from the socket, erroring
  # appropriately. Understands transfer-coding.

  # Deal with methods that cannot send a message body:
  if verb in ("GET", "HEAD", "TRACE", "DELETE"):
    if "Content-Length" in headers or "Transfer-Encoding" in headers:
      raise _httpserver_BadRequest("Method '" + verb + "' cannot send " + \
          "an entity-body and therefore a Content-Length or " + \
          "Transfer-Encoding header is invalid.")
    else:
      return (None, data)

  # Deal with methods that send a message body.
  if "Content-Length" not in headers and "Transfer-Encoding" not in headers:
    raise _httpserver_BadRequest("Method '" + str(verb) + "' can send an " + \
        "entity-body and requires a Content-Length or Transfer-Encoding " + \
        "header.")

  rawdata = data
  if "Transfer-Encoding" in headers:
    # Decode Transfer-coded messages
    if len(headers["Transfer-Encoding"]) != 1:
      raise _httpserver_BadRequest("Multiple Transfer-Encoding headers is " + \
          "unacceptable.")

    # "chunked" must be in the codings list, and it must be last.
    codings = headers["Transfer-Encoding"][0].split(",")
    codings.reverse()

    realcodings = []

    # Strip 'identity' codings.
    for coding in codings:
      coding = coding.strip().lower()
      token = coding.split(None, 1)
      if token != "identity":
        realcodings.append(coding)
    
    if len(realcodings) > 1 or realcodings[0] != "chunked":
      raise _httpserver_BadTransferCoding("Cannot handle any transfer-" + \
          "codings other than chunked.")

    # Loop through chunks
    data = ""
    while True:
      line, rawdata = _httpserver_getline(sock, rawdata)
      chunksz = int(line.split(";", 1)[0].strip(), 16)

      if chunksz == 0:
        break

      chunk, rawdata = _httpserver_getblock(chunksz+2, sock, rawdata)
      data += chunk[:-2]  # remove CRLF

    # Read 'trailer' headers.
    while True:
      line, rawdata = _httpserver_getline(sock, rawdata)
      if len(line.strip("\r")) == 0:
        break
      # Check for a multi-line header by peeking ahead:
      while True:
        nextchar, rawdata = _httpserver_getblock(1, sock, rawdata)
        rawdata = nextchar + rawdata
        if nextchar in (" ", "\t"):
          line2, rawdata = _httpserver_getline(sock, rawdata)
          line += " " + line2
        else:
          break

      # Insert header into existing headers
      hdrname, hdrval = line.split(":", 1)
      if hdrname not in headers:
        headers[hdrname] = []
      headers[hdrname].append(hdrval)

    # Set new content-length, remove transfer-encoding.
    headers["Content-Length"] = [len(data)]
    del headers["Transfer-Encoding"]

    return (data, rawdata)

  else:
    # If we get here, that means we have a Content-Length and no Transfer-
    # Encoding, so we can read the message body directly.
    msglen = headers["Content-Length"]

    if len(msglen) != 1:
      raise _httpserver_BadRequest("Multiple Content-Length headers is " + \
          "unacceptable.")
    
    msglen = int(msglen[0])
    return _httpserver_getblock(msglen, sock, rawdata)




def _httpserver_getline(sock, data):
  # Reads a line out of data (if possible), or failing that, gets more from
  # the socket. Returns (line, extra).

  try:
    newdata = ""
    while True:
      end = data.find("\n", -len(newdata))
      if end != -1:
        return (data[:end], data[end+1:])
      newdata = sock.recv(4096)
      data += newdata
  except Exception, e:
    if "Socket closed" in str(e) and len(data) != 0:
      return (data, "")
    raise




def _httpserver_getblock(size, sock, data):
  # Reads a block of size size out of data (if possible), or failing that,
  # gets more from the socket. Returns (block, extra).

  try:
    while len(data) < size:
      data += sock.recv(4096)

    return (data[:size], data[size:])
  except Exception, e:
    if "Socket closed" in str(e) and len(data) != 0:
      return (data, "")
    raise




def httpserver_stopcallback(id):
  """
  <Purpose>
    Removes an existing callback function.

  <Arguments>
    id:
      The id returned by httpserver_registercallback().

  <Exceptions>
    IndexError, KeyError if the id is invalid or has already been deleted.

  <Side Effects>
    Removes this listener from the registry, deletes the listening socket.

  <Returns>
    Nothing.

  """
  _httpserver_context['lock'].acquire()
  try:
    stopcomm(_httpserver_context['handles'][id])
    del _httpserver_context['handles'][id]
    del _httpserver_context['cbfuncs'][id]
  finally:
    _httpserver_context['lock'].release()
